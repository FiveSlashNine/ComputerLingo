[
  {
    "id": 1,
    "title": "Level 3: Time Complexity",
    "type": "multiple-choice",
    "question": "What is the average-case time complexity of Merge Sort?",
    "options": [
      { "id": "a", "text": "O(n)" },
      { "id": "b", "text": "O(n log n)" },
      { "id": "c", "text": "O(n^2)" },
      { "id": "d", "text": "O(log n)" }
    ],
    "correctAnswer": "b",
    "icon": "Code2"
  },
  {
    "id": 2,
    "title": "Level 3: Algorithm Analysis",
    "type": "true-false",
    "question": "A greedy algorithm always produces the optimal solution for all optimization problems.",
    "correctAnswer": false,
    "icon": "SlidersHorizontal"
  },
  {
    "id": 3,
    "title": "Level 3: Recursion Optimization",
    "type": "fill-blanks",
    "question": "Complete the base case for a factorial function using recursion:",
    "codeTemplate": "function factorial(n) {\n  if (n ____ 1) return 1;\n  return n * factorial(n - 1);\n}",
    "blanks": ["<="],
    "icon": "Terminal"
  },
  {
    "id": 4,
    "title": "Level 3: Graph Traversal",
    "type": "drag-drop",
    "question": "Arrange the steps of the Depth-First Search (DFS) algorithm:",
    "items": [
      { "id": "1", "text": "Mark the current node as visited" },
      { "id": "2", "text": "Recursively visit each unvisited neighbor" },
      { "id": "3", "text": "Start at the root node" },
      { "id": "4", "text": "Repeat until all nodes are visited" }
    ],
    "correctOrder": ["3", "1", "2", "4"],
    "icon": "ListChecks"
  },
  {
    "id": 5,
    "title": "Level 3: Big-O Notation",
    "type": "multiple-choice",
    "question": "Which function has the fastest growth rate?",
    "options": [
      { "id": "a", "text": "O(n log n)" },
      { "id": "b", "text": "O(n^2)" },
      { "id": "c", "text": "O(2^n)" },
      { "id": "d", "text": "O(n!)" }
    ],
    "correctAnswer": "d",
    "icon": "Code2"
  },
  {
    "id": 6,
    "title": "Level 3: Dynamic Programming",
    "type": "true-false",
    "question": "Dynamic programming is only useful when there are overlapping subproblems and optimal substructure.",
    "correctAnswer": true,
    "icon": "SlidersHorizontal"
  },
  {
    "id": 7,
    "title": "Level 3: Bit Manipulation",
    "type": "fill-blanks",
    "question": "Complete the expression to check if a number is a power of two:",
    "codeTemplate": "(n & (n - 1)) ____ 0",
    "blanks": ["=="],
    "icon": "Terminal"
  },
  {
    "id": 8,
    "title": "Level 3: Graph Theory",
    "type": "drag-drop",
    "question": "Order the steps to perform Breadth-First Search (BFS):",
    "items": [
      { "id": "1", "text": "Repeat until the queue is empty" },
      { "id": "2", "text": "Dequeue a node and visit it" },
      { "id": "3", "text": "Add the starting node to a queue" },
      { "id": "4", "text": "Enqueue unvisited adjacent nodes" }
    ],
    "correctOrder": ["3", "2", "4", "1"],
    "icon": "ListChecks"
  },
  {
    "id": 9,
    "title": "Level 3: Complexity Classes",
    "type": "multiple-choice",
    "question": "Which of the following problems is known to be NP-Complete?",
    "options": [
      { "id": "a", "text": "Binary Search" },
      { "id": "b", "text": "Traveling Salesman Problem" },
      { "id": "c", "text": "Merging two sorted arrays" },
      { "id": "d", "text": "Heap Sort" }
    ],
    "correctAnswer": "b",
    "icon": "Code2"
  },
  {
    "id": 10,
    "title": "Level 3: Divide and Conquer",
    "type": "true-false",
    "question": "Quick Sort uses the divide and conquer strategy.",
    "correctAnswer": true,
    "icon": "SlidersHorizontal"
  },
  {
    "id": 11,
    "title": "Level 3: Algorithm Optimization",
    "type": "fill-blanks",
    "question": "Complete the code to memoize the Fibonacci function:",
    "codeTemplate": "function fib(n, memo = {}) {\n  if (n in memo) return memo[n];\n  if (n <= 1) return n;\n  return memo[n] = fib(n - 1, memo) + fib(____, memo);\n}",
    "blanks": ["n - 2"],
    "icon": "Terminal"
  },
  {
    "id": 12,
    "title": "Level 3: Graph Cycles",
    "type": "drag-drop",
    "question": "Arrange the steps to detect a cycle in a directed graph using DFS:",
    "items": [
      { "id": "1", "text": "Track nodes in the current recursion stack" },
      { "id": "2", "text": "If a neighbor is in the recursion stack, a cycle exists" },
      { "id": "3", "text": "Mark the node as visited and add it to the recursion stack" },
      { "id": "4", "text": "Remove the node from the recursion stack on return" }
    ],
    "correctOrder": ["3", "1", "2", "4"],
    "icon": "ListChecks"
  },
  {
    "id": 13,
    "title": "Level 3: Data Structures",
    "type": "multiple-choice",
    "question": "Which data structure is best suited for implementing Dijkstra's algorithm efficiently?",
    "options": [
      { "id": "a", "text": "Stack" },
      { "id": "b", "text": "Queue" },
      { "id": "c", "text": "Priority Queue (Min-Heap)" },
      { "id": "d", "text": "Hash Table" }
    ],
    "correctAnswer": "c",
    "icon": "Code2"
  },
  {
    "id": 14,
    "title": "Level 3: Recursion",
    "type": "true-false",
    "question": "Tail recursion can be optimized by the compiler to avoid growing the call stack.",
    "correctAnswer": true,
    "icon": "SlidersHorizontal"
  },
  {
    "id": 15,
    "title": "Level 3: Sorting Comparison",
    "type": "fill-blanks",
    "question": "Complete the time complexity comparison:",
    "codeTemplate": "\nQuick Sort average case: O(n log n)\nWorst-case time complexity of Quick Sort is O(____)",
    "blanks": ["n^2"],
    "icon": "Terminal"
  },
  {
    "id": 16,
    "title": "Level 3: Hashing",
    "type": "drag-drop",
    "question": "Arrange steps for resolving collisions using separate chaining in a hash table:",
    "items": [
      { "id": "1", "text": "Check if the key already exists in the linked list" },
      { "id": "2", "text": "Insert a new node at the head of the list" },
      { "id": "3", "text": "Hash the key to find the index" },
      { "id": "4", "text": "Traverse the list at that index" }
    ],
    "correctOrder": ["3", "4", "1", "2"],
    "icon": "ListChecks"
  },
  {
    "id": 17,
    "title": "Level 3: Greedy Algorithms",
    "type": "multiple-choice",
    "question": "Which of the following problems can be optimally solved using a greedy algorithm?",
    "options": [
      { "id": "a", "text": "Knapsack Problem (0/1)" },
      { "id": "b", "text": "Traveling Salesman Problem" },
      { "id": "c", "text": "Activity Selection Problem" },
      { "id": "d", "text": "Longest Common Subsequence" }
    ],
    "correctAnswer": "c",
    "icon": "Code2"
  },
  {
    "id": 18,
    "title": "Level 3: Space Complexity",
    "type": "true-false",
    "question": "Recursive algorithms always use more space than iterative ones.",
    "correctAnswer": false,
    "icon": "SlidersHorizontal"
  },
  {
    "id": 19,
    "title": "Level 3: Graph Algorithms",
    "type": "fill-blanks",
    "question": "Complete the function to add an edge in an adjacency list representation:",
    "codeTemplate": "function addEdge(graph, u, v) {\n  if (!graph[u]) graph[u] = [];\n  graph[u].____(v);\n}",
    "blanks": ["push"],
    "icon": "Terminal"
  },
  {
    "id": 20,
    "title": "Level 3: DP Algorithm Steps",
    "type": "drag-drop",
    "question": "Arrange the steps for solving a problem using dynamic programming (bottom-up):",
    "items": [
      { "id": "1", "text": "Build a table to store results" },
      { "id": "2", "text": "Identify subproblems" },
      { "id": "3", "text": "Fill the table iteratively" },
      { "id": "4", "text": "Return the final value" }
    ],
    "correctOrder": ["2", "1", "3", "4"],
    "icon": "ListChecks"
  }
]
