{
  "category": "algorithms",
  "level": "intermediate",
  "topics": [
    {
      "title": "Sorting",
      "tutorial": "Merge Sort and Quick Sort are common O(n log n) algorithms. Merge Sort splits the list and merges sorted halves. Quick Sort partitions around a pivot and sorts subarrays.",
      "questions": [
        {
          "id": "int-sort-q1",
          "type": "multiple-choice",
          "question": "What is the average-case time complexity of Quick Sort?",
          "options": [
            "O(n)",
            "O(n log n)",
            "O(n\u00b2)",
            "O(log n)"
          ],
          "correctAnswer": "O(n log n)",
          "icon": "TrendingUp"
        },
        {
          "id": "int-sort-q2",
          "type": "true-false",
          "question": "Merge Sort requires O(n) extra space in its typical implementation.",
          "correctAnswer": true,
          "icon": "Layers"
        },
        {
          "id": "int-sort-q3",
          "type": "fill-blanks",
          "question": "Quick Sort\u2019s worst-case occurs when the pivot is consistently the ____ element.",
          "codeTemplate": "",
          "blanks": [
            "smallest or largest"
          ],
          "icon": "AlertCircle"
        },
        {
          "id": "int-sort-q4",
          "type": "drag-drop",
          "question": "Match each algorithm to its characteristic:",
          "items": [
            {
              "id": "A",
              "text": "Merge Sort"
            },
            {
              "id": "B",
              "text": "Quick Sort"
            }
          ],
          "correctOrder": [
            "A\u2192Stable, uses extra space",
            "B\u2192In-place, average O(n log n)"
          ],
          "icon": "Shuffle"
        },
        {
          "id": "int-sort-q5",
          "type": "multiple-choice",
          "question": "Which pivot selection avoids Quick Sort\u2019s worst-case on sorted input?",
          "options": [
            "First element",
            "Last element",
            "Random element",
            "Median-of-three"
          ],
          "correctAnswer": "Median-of-three",
          "icon": "Search"
        },
        {
          "id": "int-sort-q6",
          "type": "true-false",
          "question": "Quick Sort is not a stable sort.",
          "correctAnswer": true,
          "icon": "X"
        },
        {
          "id": "int-sort-q7",
          "type": "multiple-choice",
          "question": "Introsort switches to Heap Sort if recursion depth exceeds a multiple of log n. True or false?",
          "options": [
            "True",
            "False"
          ],
          "correctAnswer": "True",
          "icon": "Code"
        }
      ]
    },
    {
      "title": "Searching",
      "tutorial": "Binary Search runs in O(log n) on sorted arrays. Hash-based lookup can achieve average O(1) time. Trees (e.g. BST) offer O(log n) average but degrade to O(n).",
      "questions": [
        {
          "id": "int-search-q1",
          "type": "multiple-choice",
          "question": "Which data structure gives average O(1) lookup time?",
          "options": [
            "Array",
            "Hash table",
            "BST",
            "Linked list"
          ],
          "correctAnswer": "Hash table",
          "icon": "Hash"
        },
        {
          "id": "int-search-q2",
          "type": "true-false",
          "question": "Binary Search can be applied recursively.",
          "correctAnswer": true,
          "icon": "Repeat"
        },
        {
          "id": "int-search-q3",
          "type": "fill-blanks",
          "question": "In a hash table with chaining, worst-case lookup is O(___).",
          "codeTemplate": "",
          "blanks": [
            "n"
          ],
          "icon": "Layers"
        },
        {
          "id": "int-search-q4",
          "type": "drag-drop",
          "question": "Match each search to its data requirement:",
          "items": [
            {
              "id": "X",
              "text": "Binary Search"
            },
            {
              "id": "Y",
              "text": "Hash Lookup"
            }
          ],
          "correctOrder": [
            "X\u2192Sorted array",
            "Y\u2192Hashable keys"
          ],
          "icon": "SortAscending"
        },
        {
          "id": "int-search-q5",
          "type": "multiple-choice",
          "question": "Binary Search average complexity is O(log n). True or false?",
          "options": [
            "True",
            "False"
          ],
          "correctAnswer": "True",
          "icon": "TrendingUp"
        },
        {
          "id": "int-search-q6",
          "type": "true-false",
          "question": "Hash Lookup worst-case is O(n).",
          "correctAnswer": true,
          "icon": "AlertCircle"
        },
        {
          "id": "int-search-q7",
          "type": "multiple-choice",
          "question": "Interpolation Search average complexity is O(log log n).",
          "options": [
            "True",
            "False"
          ],
          "correctAnswer": "True",
          "icon": "Code"
        }
      ]
    },
    {
      "title": "Recursion",
      "tutorial": "Divide-and-conquer recursions like Merge Sort use multiple recursive calls. Tail recursion can be optimized to loops. Memoization turns exponential recurrences into linear or polynomial.",
      "questions": [
        {
          "id": "int-recur-q1",
          "type": "multiple-choice",
          "question": "What technique stores previous results to speed up recursion?",
          "options": [
            "Backtracking",
            "Memoization",
            "Iteration",
            "Greedy"
          ],
          "correctAnswer": "Memoization",
          "icon": "Layers"
        },
        {
          "id": "int-recur-q2",
          "type": "true-false",
          "question": "A tail-recursive function can be optimized into an iterative loop.",
          "correctAnswer": true,
          "icon": "Shuffle"
        },
        {
          "id": "int-recur-q3",
          "type": "fill-blanks",
          "question": "Naive Fibonacci recursion runs in O(___).",
          "codeTemplate": "",
          "blanks": [
            "2^n"
          ],
          "icon": "Function"
        },
        {
          "id": "int-recur-q4",
          "type": "drag-drop",
          "question": "Order steps for top-down DP:",
          "items": [
            {
              "id": "1",
              "text": "Define recursion"
            },
            {
              "id": "2",
              "text": "Check memo"
            },
            {
              "id": "3",
              "text": "Compute and store"
            },
            {
              "id": "4",
              "text": "Return"
            }
          ],
          "correctOrder": [
            "1",
            "2",
            "3",
            "4"
          ],
          "icon": "ArrowsClockwise"
        },
        {
          "id": "int-recur-q5",
          "type": "multiple-choice",
          "question": "Continuation-passing style uses which argument?",
          "options": [
            "state",
            "callback",
            "pointer",
            "stack"
          ],
          "correctAnswer": "callback",
          "icon": "Code"
        },
        {
          "id": "int-recur-q6",
          "type": "true-false",
          "question": "A trampoline function avoids deep recursion by looping.",
          "correctAnswer": true,
          "icon": "Repeat"
        }
      ]
    },
    {
      "title": "Divide and Conquer",
      "tutorial": "Karatsuba\u2019s algorithm multiplies large numbers faster by reducing to three multiplications of half-size numbers (O(n^1.585)). Strassen\u2019s matrix multiply is sub-cubic (\u2248O(n^2.81)).",
      "questions": [
        {
          "id": "int-dnc-q1",
          "type": "multiple-choice",
          "question": "Karatsuba\u2019s complexity is O(n^___).",
          "options": [
            "1.5",
            "1.585",
            "2",
            "log n"
          ],
          "correctAnswer": "1.585",
          "icon": "Calculator"
        },
        {
          "id": "int-dnc-q2",
          "type": "true-false",
          "question": "Strassen\u2019s runs in O(n^2.81).",
          "correctAnswer": true,
          "icon": "Check"
        },
        {
          "id": "int-dnc-q3",
          "type": "fill-blanks",
          "question": "Divide and conquer often follows: divide, recurse, then ___.",
          "codeTemplate": "",
          "blanks": [
            "combine"
          ],
          "icon": "Merge"
        },
        {
          "id": "int-dnc-q4",
          "type": "drag-drop",
          "question": "Match algorithms to domain:",
          "items": [
            {
              "id": "K",
              "text": "Karatsuba"
            },
            {
              "id": "S",
              "text": "Strassen"
            }
          ],
          "correctOrder": [
            "K\u2192Integer multiplication",
            "S\u2192Matrix multiplication"
          ],
          "icon": "Hash"
        },
        {
          "id": "int-dnc-q5",
          "type": "multiple-choice",
          "question": "FFT-based multiplication is O(n log n). True or false?",
          "options": [
            "True",
            "False"
          ],
          "correctAnswer": "True",
          "icon": "TrendingUp"
        },
        {
          "id": "int-dnc-q6",
          "type": "true-false",
          "question": "Coppersmith\u2013Winograd is practical for small n.",
          "correctAnswer": false,
          "icon": "AlertCircle"
        }
      ]
    },
    {
      "title": "Graph Traversal",
      "tutorial": "Dijkstra\u2019s algorithm finds shortest paths in weighted graphs (O(m + n log n)). A* adds heuristics for faster search in many cases.",
      "questions": [
        {
          "id": "int-graph-q1",
          "type": "multiple-choice",
          "question": "Which uses a priority queue?",
          "options": [
            "BFS",
            "DFS",
            "Dijkstra",
            "Bellman-Ford"
          ],
          "correctAnswer": "Dijkstra",
          "icon": "Queue"
        },
        {
          "id": "int-graph-q2",
          "type": "true-false",
          "question": "Bellman-Ford handles negative weights.",
          "correctAnswer": true,
          "icon": "Check"
        },
        {
          "id": "int-graph-q3",
          "type": "fill-blanks",
          "question": "A* uses a ____ function.",
          "codeTemplate": "",
          "blanks": [
            "heuristic"
          ],
          "icon": "Search"
        },
        {
          "id": "int-graph-q4",
          "type": "drag-drop",
          "question": "Match:",
          "items": [
            {
              "id": "1",
              "text": "BFS"
            },
            {
              "id": "2",
              "text": "A*"
            }
          ],
          "correctOrder": [
            "1\u2192Unweighted shortest",
            "2\u2192Heuristic search"
          ],
          "icon": "Map"
        },
        {
          "id": "int-graph-q5",
          "type": "multiple-choice",
          "question": "Johnson\u2019s uses Bellman-Ford then Dijkstra. True or false?",
          "options": [
            "True",
            "False"
          ],
          "correctAnswer": "True",
          "icon": "Code"
        },
        {
          "id": "int-graph-q6",
          "type": "true-false",
          "question": "Dinic\u2019s builds level graphs.",
          "correctAnswer": true,
          "icon": "Layers"
        }
      ]
    },
    {
      "title": "Greedy Algorithms",
      "tutorial": "Huffman coding builds optimal prefix codes by merging lowest-frequency nodes. Prim\u2019s algorithm grows MST by picking cheapest edge to the tree.",
      "questions": [
        {
          "id": "int-greedy-q1",
          "type": "multiple-choice",
          "question": "Huffman is optimal based on ____ frequencies.",
          "options": [
            "highest",
            "lowest",
            "average",
            "random"
          ],
          "correctAnswer": "lowest",
          "icon": "Code"
        },
        {
          "id": "int-greedy-q2",
          "type": "true-false",
          "question": "Prim and Kruskal are both greedy MST.",
          "correctAnswer": true,
          "icon": "Check"
        },
        {
          "id": "int-greedy-q3",
          "type": "fill-blanks",
          "question": "Kruskal processes edges by increasing ___.",
          "codeTemplate": "",
          "blanks": [
            "weight"
          ],
          "icon": "Layers"
        },
        {
          "id": "int-greedy-q4",
          "type": "drag-drop",
          "question": "Match outputs:",
          "items": [
            {
              "id": "H",
              "text": "Huffman"
            },
            {
              "id": "P",
              "text": "Prim"
            }
          ],
          "correctOrder": [
            "H\u2192Prefix tree",
            "P\u2192MST"
          ],
          "icon": "Tree"
        },
        {
          "id": "int-greedy-q5",
          "type": "multiple-choice",
          "question": "Greedy always finds optimal?",
          "options": [
            "True",
            "False"
          ],
          "correctAnswer": "False",
          "icon": "AlertCircle"
        }
      ]
    }
  ]
}