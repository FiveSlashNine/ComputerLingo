{
  "category": "algorithms",
  "level": "advanced",
  "topics": [
    {
      "title": "Sorting",
      "tutorial": "Advanced sorts include Introsort (Quick + Heap + Insertion) and TimSort (Merge + Insertion with runs). They optimize real-world data.",
      "questions": [
        {
          "id": "adv-sort-q1",
          "type": "multiple-choice",
          "question": "Introsort switches to Heap Sort when recursion depth exceeds ___\u00b7log n.",
          "options": [
            "1",
            "2",
            "n",
            "\u221an"
          ],
          "correctAnswer": "2",
          "icon": "TrendingUp"
        },
        {
          "id": "adv-sort-q2",
          "type": "true-false",
          "question": "TimSort detects runs to optimize sorted segments.",
          "correctAnswer": true,
          "icon": "Shuffle"
        },
        {
          "id": "adv-sort-q3",
          "type": "fill-blanks",
          "question": "Introsort guarantees worst-case O(___).",
          "codeTemplate": "",
          "blanks": [
            "n log n"
          ],
          "icon": "Code"
        },
        {
          "id": "adv-sort-q4",
          "type": "drag-drop",
          "question": "Match sort to strategy:",
          "items": [
            {
              "id": "I",
              "text": "Introsort"
            },
            {
              "id": "T",
              "text": "TimSort"
            }
          ],
          "correctOrder": [
            "I\u2192Quick\u2192Heap",
            "T\u2192Merge\u2192Insertion with runs"
          ],
          "icon": "Merge"
        },
        {
          "id": "adv-sort-q5",
          "type": "multiple-choice",
          "question": "TimSort worst-case complexity is O(n log n). True or false?",
          "options": [
            "True",
            "False"
          ],
          "correctAnswer": "True",
          "icon": "Clock"
        },
        {
          "id": "adv-sort-q6",
          "type": "true-false",
          "question": "Introsort is stable.",
          "correctAnswer": false,
          "icon": "X"
        }
      ]
    },
    {
      "title": "Searching",
      "tutorial": "Suffix Arrays allow O(m+log n) substring search; R-Trees index spatial data. Both advanced search structures.",
      "questions": [
        {
          "id": "adv-search-q1",
          "type": "multiple-choice",
          "question": "Suffix Array binary search takes O(m + log n). True or false?",
          "options": [
            "True",
            "False"
          ],
          "correctAnswer": "True",
          "icon": "Search"
        },
        {
          "id": "adv-search-q2",
          "type": "true-false",
          "question": "R-Tree is balanced for spatial indexing.",
          "correctAnswer": true,
          "icon": "Layers"
        },
        {
          "id": "adv-search-q3",
          "type": "fill-blanks",
          "question": "LCP array stores longest common ____ between suffixes.",
          "codeTemplate": "",
          "blanks": [
            "prefixes"
          ],
          "icon": "Code"
        },
        {
          "id": "adv-search-q4",
          "type": "drag-drop",
          "question": "Match index to use-case:",
          "items": [
            {
              "id": "S",
              "text": "Suffix Array"
            },
            {
              "id": "R",
              "text": "R-Tree"
            }
          ],
          "correctOrder": [
            "S\u2192String substrings",
            "R\u2192Spatial ranges"
          ],
          "icon": "Map"
        },
        {
          "id": "adv-search-q5",
          "type": "multiple-choice",
          "question": "k-d Tree partitions k-dimensional space. True or false?",
          "options": [
            "True",
            "False"
          ],
          "correctAnswer": "True",
          "icon": "Map"
        },
        {
          "id": "adv-search-q6",
          "type": "true-false",
          "question": "Trie search is O(m) for string length m.",
          "correctAnswer": true,
          "icon": "Tree"
        }
      ]
    },
    {
      "title": "Recursion & Optimization",
      "tutorial": "Techniques include CPS, trampolines, tail-call elimination, and converting recursion to iteration with stacks or DP.",
      "questions": [
        {
          "id": "adv-recur-q1",
          "type": "multiple-choice",
          "question": "CPS transforms calls into passing a ___ argument.",
          "options": [
            "state",
            "callback",
            "pointer",
            "stack"
          ],
          "correctAnswer": "callback",
          "icon": "Code"
        },
        {
          "id": "adv-recur-q2",
          "type": "true-false",
          "question": "A trampoline loops to avoid deep recursion.",
          "correctAnswer": true,
          "icon": "Repeat"
        },
        {
          "id": "adv-recur-q3",
          "type": "fill-blanks",
          "question": "Tail-call optimization removes extra ____ usage.",
          "codeTemplate": "",
          "blanks": [
            "stack"
          ],
          "icon": "Layers"
        },
        {
          "id": "adv-recur-q4",
          "type": "drag-drop",
          "question": "Order recursion-to-iteration:",
          "items": [
            {
              "id": "1",
              "text": "Identify tail calls"
            },
            {
              "id": "2",
              "text": "Accumulate result"
            },
            {
              "id": "3",
              "text": "Test base"
            },
            {
              "id": "4",
              "text": "Rewrite as loop"
            }
          ],
          "correctOrder": [
            "1",
            "2",
            "3",
            "4"
          ],
          "icon": "ArrowsClockwise"
        },
        {
          "id": "adv-recur-q5",
          "type": "multiple-choice",
          "question": "Memoization turns exponential to ___ time.",
          "options": [
            "linear",
            "logarithmic",
            "quadratic",
            "constant"
          ],
          "correctAnswer": "linear",
          "icon": "Layers"
        },
        {
          "id": "adv-recur-q6",
          "type": "true-false",
          "question": "Continuation-passing style can eliminate stack frames.",
          "correctAnswer": true,
          "icon": "Code"
        }
      ]
    },
    {
      "title": "Divide and Conquer \u2013 Advanced",
      "tutorial": "FFT multiplies polynomials in O(n log n); Strassen and Coppersmith\u2013Winograd push matrix multiply below O(n^2.4).",
      "questions": [
        {
          "id": "adv-dnc-q1",
          "type": "multiple-choice",
          "question": "FFT-based multiplication runs in O(n log n). True or false?",
          "options": [
            "True",
            "False"
          ],
          "correctAnswer": "True",
          "icon": "TrendingUp"
        },
        {
          "id": "adv-dnc-q2",
          "type": "true-false",
          "question": "Strassen\u2019s exponent \u22482.81.",
          "correctAnswer": true,
          "icon": "Check"
        },
        {
          "id": "adv-dnc-q3",
          "type": "fill-blanks",
          "question": "Coppersmith\u2013Winograd exponent \u2248 ___.",
          "codeTemplate": "",
          "blanks": [
            "2.376"
          ],
          "icon": "Calculator"
        },
        {
          "id": "adv-dnc-q4",
          "type": "drag-drop",
          "question": "Match algorithm to exponent:",
          "items": [
            {
              "id": "S",
              "text": "Strassen"
            },
            {
              "id": "C",
              "text": "C-W"
            }
          ],
          "correctOrder": [
            "S\u21922.81",
            "C\u21922.376"
          ],
          "icon": "Math"
        },
        {
          "id": "adv-dnc-q5",
          "type": "multiple-choice",
          "question": "Divide and conquer always reduces exponent?",
          "options": [
            "True",
            "False"
          ],
          "correctAnswer": "False",
          "icon": "Code"
        },
        {
          "id": "adv-dnc-q6",
          "type": "true-false",
          "question": "FFT uses roots of unity.",
          "correctAnswer": true,
          "icon": "Layers"
        }
      ]
    },
    {
      "title": "Graph Algorithms",
      "tutorial": "Johnson\u2019s APSP uses Bellman-Ford + Dijkstra; Dinic\u2019s max-flow uses level graphs and blocking flow.",
      "questions": [
        {
          "id": "adv-graph-q1",
          "type": "multiple-choice",
          "question": "Dinic\u2019s algorithm uses BFS to build a ___ graph.",
          "options": [
            "residual",
            "complete",
            "spanning",
            "directed"
          ],
          "correctAnswer": "residual",
          "icon": "Queue"
        },
        {
          "id": "adv-graph-q2",
          "type": "true-false",
          "question": "Johnson\u2019s adds potentials to remove negatives.",
          "correctAnswer": true,
          "icon": "Code"
        },
        {
          "id": "adv-graph-q3",
          "type": "fill-blanks",
          "question": "Dinic\u2019s on unit networks is O(\u221aV\u00b7___).",
          "codeTemplate": "",
          "blanks": [
            "E"
          ],
          "icon": "Calculator"
        },
        {
          "id": "adv-graph-q4",
          "type": "drag-drop",
          "question": "Match step to algorithm:",
          "items": [
            {
              "id": "J",
              "text": "Johnson\u2019s"
            },
            {
              "id": "D",
              "text": "Dinic\u2019s"
            }
          ],
          "correctOrder": [
            "J\u2192Reweight",
            "D\u2192Blocking flow"
          ],
          "icon": "Layers"
        },
        {
          "id": "adv-graph-q5",
          "type": "multiple-choice",
          "question": "Bellman-Ford complexity is O(VE). True or false?",
          "options": [
            "True",
            "False"
          ],
          "correctAnswer": "True",
          "icon": "Clock"
        },
        {
          "id": "adv-graph-q6",
          "type": "true-false",
          "question": "Edmonds-Karp uses BFS for augmenting paths.",
          "correctAnswer": true,
          "icon": "Map"
        }
      ]
    },
    {
      "title": "Greedy & Beyond",
      "tutorial": "Matroid greedy and approximation algorithms (e.g., set cover ln n). Greedy-set-cover achieves O(ln n) approximation.",
      "questions": [
        {
          "id": "adv-greedy-q1",
          "type": "multiple-choice",
          "question": "Matroid exchange property holds for ___.",
          "options": [
            "circuits",
            "bases",
            "weights",
            "vertices"
          ],
          "correctAnswer": "bases",
          "icon": "Code"
        },
        {
          "id": "adv-greedy-q2",
          "type": "true-false",
          "question": "Set cover greedy is O(ln n) approximation.",
          "correctAnswer": true,
          "icon": "AlertCircle"
        },
        {
          "id": "adv-greedy-q3",
          "type": "fill-blanks",
          "question": "Graphic matroid independent sets are ___.",
          "codeTemplate": "",
          "blanks": [
            "forests"
          ],
          "icon": "Tree"
        },
        {
          "id": "adv-greedy-q4",
          "type": "drag-drop",
          "question": "Match concept to definition:",
          "items": [
            {
              "id": "M",
              "text": "Matroid"
            },
            {
              "id": "A",
              "text": "Approximation"
            }
          ],
          "correctOrder": [
            "M\u2192Exchange",
            "A\u2192ln n"
          ],
          "icon": "Math"
        },
        {
          "id": "adv-greedy-q5",
          "type": "multiple-choice",
          "question": "Greedy works on all matroids. True or false?",
          "options": [
            "True",
            "False"
          ],
          "correctAnswer": "True",
          "icon": "Check"
        }
      ]
    }
  ]
}